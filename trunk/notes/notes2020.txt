Tom's port notes from 2020.

Steinberg hates VST2SDK now and is trying to expunge it from the internet.
But I found my old copy from like 2001 (matching the file sizes in the vstsdk/README). Unknown whether it works with 64 bit yet.

We could port to VST3, and this would be preferable, but it looks somewhat
painful. At least the way dfx-library is set up, we could add a TARGET_API_VST3 (maybe rename the current one to VST2, maybe even do that anyway) and do
this without necessarily disrupting the VST2 build.

Our plugins implement DfxPlugin, which itself can be compiled as an AU
or VST (maybe other stuff) and have various features turned on and off; these
are all compile-time settings through #defines. In VST (2) mode, it implements
AudioEffectX. (I think AudioEffect is like VST1 even?)


OK so the header versions from 2001 probably won't work, because they
use "long" (which is likely 64 bit in 2020) when they mean int32. I
think this may be part of the external interface and really is expected
to be 32 bit.

Looks like at some point this type was replaced with VstInt32. So instead
I grabbed the headers from pluginterfaces/vst2.x/ inside vst-sdk_3.6.14.


... Well, I compiled a DLL (without GUI).

Here's what mingw gendef (compiled it myself, in d:\temp\mingw...something...tools...\gendef) shows
for a working plugin:

$ ./gendef.exe - "c:\Program Files\Steinberg\VstPlugins\iZVocalDoubler.dll"
 * [c:\Program Files\Steinberg\VstPlugins\iZVocalDoubler.dll] Found PE+ image
;
; Definition file of iZVocalDoubler.dll
; Automatic generated by gendef
; written by Kai Tietz 2008
;
LIBRARY "iZVocalDoubler.dll"
EXPORTS
PluginCoreCallback
RWDEFCloseDevice
RWDEFDriveAudio
RWDEFGetDeviceInfo
RWDEFGetDeviceNameAndVersion
RWDEFGetDeviceSignature
RWDEFGetEventBusInfo
RWDEFGetEventChannelInfo
RWDEFGetEventControllerInfo
RWDEFGetEventInfo
RWDEFGetEventNoteInfo
RWDEFIdle
RWDEFIsCloseOK
RWDEFIsPanelAppLaunched
RWDEFLaunchPanelApp
RWDEFOpenDevice
RWDEFQuitPanelApp
RWDEFSetAudioInfo


$ ./gendef.exe - "c:\code\destroyfx\transverb\win32\dfx-transverb-64.dll"
 * [c:\code\destroyfx\transverb\win32\dfx-transverb-64.dll] Found PE+ image
;
; Definition file of dfx-transverb-64.dll
; Automatic generated by gendef
; written by Kai Tietz 2008
;
LIBRARY "dfx-transverb-64.dll"
EXPORTS
MAIN
VSTPluginMain
_Z11besselIZerof
_Z12besselIZero2f
_Z20createEffectInstancePFxP7AEffectiixPvfE
_ZN10AEffEditor11setKnobModeEi
_ZN10AEffEditor4idleEv
_ZN10AEffEditor4openEPv
... and a jillion more ...

So are we supposed to be exporting PluginCoreCallback somehow?

actually maybe the iZ version is actually some other format. Here's "Vocal Doubler.dll":

$ ./gendef.exe - "c:\Program Files\Steinberg\VstPlugins\Vocal Doubler.dll"
 * [c:\Program Files\Steinberg\VstPlugins\Vocal Doubler.dll] Found PE+ image
;
; Definition file of PluginHooksVST.dll
; Automatic generated by gendef
; written by Kai Tietz 2008
;
LIBRARY "PluginHooksVST.dll"
EXPORTS
GetPluginFactory
PluginHookCallback
VSTPluginMain
main


GetPluginFactory appears to be VST3: https://sdk.steinberg.net/viewtopic.php?t=521
PluginHookCallbakc appears to be iZotope (made vocal doubler) specific (only hit
for "PluginHookCallback VST" is iZotope being identified as malware, has strings dump)



The 64-bit headers differ in a number of places dfx transverb:
Magic      523
MajorLinkerVersion        02
MinorLinkerVersion         22
SizeOfCode          155648
SizeOfInitializedData    223232
SizeOfUninitializedData        5120
AddressOfEntryPoint        4912
BaseOfCode          4096
ImageBase            1790181376
SectionAlignment              4096
FileAlignment    512
MajorOperatingSystemVersion        4
MinorOperatingSystemVersion        0
MajorImageVersion            0
MinorImageVersion            0
MajorSubsystemVersion    5
MinorSubsystemVersion    2
Win32VersionValue            0
SizeOfImage        659456
SizeOfHeaders    1536
CheckSum              770609
Subsystem            3
DllCharacteristics          0
SizeOfStackReserve          2097152
SizeOfStackCommit            4096
SizeOfHeapReserve            1048576
SizeOfHeapCommit              4096
LoaderFlags        0
NumberOfRvaAndSizes        16

vocal doubler:
Magic      523
MajorLinkerVersion        0e
MinorLinkerVersion         10
SizeOfCode          2712064
SizeOfInitializedData    1749504
SizeOfUninitializedData        0
AddressOfEntryPoint        1743044
BaseOfCode          4096
ImageBase            6442450944
SectionAlignment              4096
FileAlignment    512
MajorOperatingSystemVersion        6
MinorOperatingSystemVersion        0
MajorImageVersion            0
MinorImageVersion            0
MajorSubsystemVersion    6
MinorSubsystemVersion    0
Win32VersionValue            0
SizeOfImage        4505600
SizeOfHeaders    1024
CheckSum              0
Subsystem            2
DllCharacteristics          352
SizeOfStackReserve          1048576
SizeOfStackCommit            4096
SizeOfHeapReserve            1048576
SizeOfHeapCommit              4096
LoaderFlags        0
NumberOfRvaAndSizes        16


the OS and subsystem versions seem to indicate that the mingw dll will work on older windowses, which is fine.
Subsystem is interesting. vocal-doubler is IMAGE_SUBSYSTEM_WINDOWS_GUI and mingw is IMAGE_SUBSYSTEM_WINDOWS_CUI.
-mwindows ? https://gcc.gnu.org/onlinedocs/gcc/x86-Windows-Options.html
(yes this works, also there is --Wl,--subsystem,windows or something like that)


With __declspec(dllexport) _cdecl on VSTPluginMain, it looks like we ONLY export that symbol now.
This seems better?

Still no loady though.

vocal-doubler has these DllCharacteristics (352 = 0x160):

IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA 0x0020
Image can handle a high entropy 64-bit virtual address space.
IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040
DLL can be relocated at load time.
IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100
Image is NX compatible.

probably 20 and 100 are security stuff we can ignore for this case, but dynamic base might be important?
Actually dynamic base is ASLR (address space randomization) support, so all three of these are probably
just for that and unnecessary.


Added some hacky message box / file log style debugging to vstplugmain, and it looks like it's never called.
So does VstPlugMain not link, or it can't dlopen or whatever?


OK, so trying to load it myself with LoadLibraryExA, it just fails:

$ ./load.exe vocal-doubler.dll

Tom@STARTROPICS /c/code/destroyfx/transverb/win32
$ ./load.exe dfx-transverb-64.dll
Failed:
LoadLibraryExA failed (null) failed with error 193: %1 is not a valid Win32 appl
ication.

several internet sources claim this actually means it is a 32-bit DLL. (Or at least this
would be a symptom...) Indeeed if I pass most other garbage to load.exe (e.g. resources.o renamed
to resources.dll) it gives me a different error "5: access denied".


x86_64-w64-mingw32-objdump -x file.dll
is a good way to look at details. The dlls are pretty similar aside from the header differences
noted above. One thing that jumps out is that transverb needs two GCC DLLs:

 00034000       000340a0 00000000 00000000 000350a0 00034418

        DLL Name: libgcc_s_seh-1.dll
        vma:  Hint/Ord Member-Name Bound-To
        34790      15  _Unwind_Resume
        347a4     105  __popcountdi2

 00034014       000340b8 00000000 00000000 00035130 00034430

        DLL Name: libstdc++-6.dll
        vma:  Hint/Ord Member-Name Bound-To
        347b4    1115  _ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEy
        347ec    1116  _ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEyyy

... which maybe LoadLibrary is not finding?

another thing I could imagine is that vocal-doubler has a "main" exported.

both files have a bunch of "xdata section corrupt" stuff, so I don't think that's a real problem.


-static-libgcc -static-libstdc++ to the linker do successfully remove imports for these dlls, nice
(but there is libwinpthread-1.dll)

just putting libwinpthread-1.dll in the pwd allows ./load.exe to load it, then (what a useless
error message??!). We see the MessageBoxA and log output (DllMain).

cakewalk still does not care for it, and doesn't show message boxes. It might not be finding the dll
(even when I put it in vstplugins too?) or there might still be a problem with the way VSTPluginMain is
exported.

Can we link (only) pthreads statically?
Well, you can include it on the linker command line as an object (the .a):
/usr/x86_64-w64-mingw32/sys-root/mingw/lib/libwinpthread.a

and now load.exe works without pthread dll in the cwd.

and now bandcamp at least calls the DllMain MessageBox, and creates and returns the effect!

(Note that bandcamp definitely needs you to do utilities ... plugin manager ... scan vst plug-ins (and check
those options) even if you replace the dll.)


When I add the plugin it's definitely doing something (shows builtin ui with parameters and some reasonable
default settings) but then also crashes:

"unhandled exception"
exception code c0000005
address nonzero:zero:00000000...00065

c0000005 is an access violation, so it's probably just crashing due to some busted vst code
(which I have some chance of debugging now...!)


(it was just a silly bug, works now!)

---

vstgui

vstgui is open source. maybe we should just be including it in dfx repository.
looks like the current version still has hooks for targeting vst2.
I think dfxgui is using vstgui even when the plugin target is not VST, actually. At least it is including some of those types...

hint: mingw windows headers are in /usr/x86_64-w64-mingw32/sys-root/mingw/include



dfx "properties"
... this seems to be an AU concept, since in AU mode it directly calls AudioUnitGetProperty (at least dfxgui_GetProperty does).
But also we add new properties in e.g. geometer:
enum : dfx::PropertyID { PROP_LAST_WINDOW_TIMESTAMP = dfx::kPluginProperty_EndOfList,
                         PROP_WAVEFORM_DATA
};
... seems like this thing could be made typesafe (e.g. the property knows its type and so we can deduce the size) if we wanted,
at least the dfx parts. But I don't really get why geometerview can't like getPlugin() and then downcast to Geometer* and
call GetWaveform rather than go through an enumeration of properties and void*s? We don't want the editor to have the
definition of the plugin class?
(According to Sophia, in AU you can't even assume the editor and effect are part of the same *process*, so it makes
sense...)


---

In load.exe, building a minimal "host" to understand what the startup
sequence should be (and why the gui doesn't show).
"Flags" are an old aeffect concept. "has editor" gets set if you setEditor and stuff like "uses chunks" is
set by calling methods of the audioeffect class during startup, like programsAreChunks(true). This is
done by dfxplugin.cpp in its constructor.

The "has effect" flag is set (expected) but the dfx library ctor only sets the editor member (of base class AEffect)
rather than calling setEditor. How did that happen? Well it turns out that vstgui's AEffGUIEditor constructor
(plugin-bindings/aeffguieditor.cpp) calls setEditor(this). Probably we should not manually assign editor, but
wait unil I have a working build before mucking with such things.


Here's why the editor doesn't open:
	auto const baseSuccess = TARGET_API_EDITOR_BASE_CLASS::open(inWindow);
	if (!baseSuccess)

Base class is VSTGUI::AEffGUIEditor whose open just forwards the pointer to AEffEditor::open (one of its base
classes). On my platform at least, this is

	virtual bool open (void* ptr)		{ systemWindow = ptr; return 0; }

it's not a virtual call so this always fails?
(I "fixed" this by ignoring the failure in vst; other fixes would require changing vstgui or vst sdk)


in vstgui, makeOwned is basically std::make_shared.
DGImage is really just vstgui's CBitmap, which is constructed from a CResourceDescription (utf8 string or number).
So this should actually already work (!) on windows, except that the resources file gives them numbers,
not names.

and, aha, it was failing to find them by number. Would be maybe nice if the DGImage wrapper gave some feedback
in this case instead of just having blank images.

-------
Striping DLL. Pass -s to linker.
Definitely do this for release! 18mb unstripped, 2.5mb stripped.
This does change what 'file' reports on the dll. Unstripped:
dfx-transverb-64.dll: PE32+ executable (DLL) (GUI) x86-64, for MS Windows
Stripped:
dfx-transverb-64.dll: PE32+ executable (DLL) (GUI) x86-64 (stripped to external PDB), for MS Windows

The reference DLL looks like the first one, but the stripped DLL does load in Cakewalk.

---

Transverb crashes upon close:

In VST this is initiated by an effClose (or is it effEditClose? or both?) message, which gets
passed on to the close() virtual method of DfxPlugin. (Looks like both the editor and plugin get
close messages. editor likely goes first because dispatchEffectClass deletes the audioeffect
after dispatching to close()).

DFXPlugin::close() runs, calling
	DFX_UnregisterIdleClient(this);
	dfx_PreDestructor();
	do_cleanup();
and the crash happens after returning. So I'm guessing it actually happens in the destructor?

DfxPlugin is just the default constructor, so I guess one of the members' destructors?
Actually with more instrumentation it seems that ~DfxPlugin successfully finishes.


audioeffect.cpp effClose, which calls close()
  DfxPlugin::close
  do_pd:cleanup
    (note, dfxplugin wasn't initialized!)
  do_pd:cleanup returns
audioeffect effClose deletes AudioEffect:
  ~Transverb
  ~DfxPlugin
   manually clearing:
     ~TransverbDSP
     ~TransverbDSP
     dspcores cleared
   ~DfxSettings
Now the last thing that happens during ~AudioEffect is to delete the editor.
So basically, the editor should NOT assume it has any access to the effect
in its destructor.
  ~TransverbEditor
  ~DfxGuiEditor
   close()
   setmidilearning
     geteffectinstance
     CRASH (makes sense; ~Transverb was already destroyed)
     

So basically, the editor tries to access the effect during the destructor.
Definitely not clear to me which order these are "supposed" to happen in,
but VST will delete the editor if it's non-null at the end of ~AudioEffect,
so if we do want the editor to be deleted first, we need to do it ourselves.
We can do this in do_PreDestructor. ~DfxPlugin is not right because subclasses
would have already had their destructors run, and the editor could do
virtual dispatch to them while they're in this invalid state.
 

Custom font loading:
 - Should be possible to embed this in the DLL. VSTGUI has support for this; CFontDesc calls
   IPlatformFont::Create, which (win32support.cpp) calls the D2DFont constructor. D2DFont
   is a direct2d thing that was reworked in Windows 10 1703, which came out in 2017.
   So we could just use that and require newish windows 10? Seems a little aggressive, but
   it would only get better over time?
 - I think there are very old APIs for registering fonts that should be pretty easy, though?
    - PrivateFontCollection::AddMemoryFont in GDI+ (mingw32 support?)
    - AddFontResourceExA is the underlying GDI function, or I guess AddFontMemResourceEx.
    - Wow yes, AddFontResourceExA worked the first time... let's just do this.
      (One annoyance for debugging is that it installs the font until reboot, and you can't
       even uninstall it, so testing that this is working may require some rebooting)
 - Also would be easy to just embed this font as a bitmap, which would also sidestep the
   finnicky cross-platform rendering. I think VSTGui wants to handle the text drawing, though;
   we'd have to like implement our own IPlatformFont? (It actually looks pretty doable.
   CFontDesc is all virtual, and you basically just have to return the metrics and
   draw a string using CDrawContext, which would be easy for bitmaps. With this approach we might
   have to give up on Boring Boron, though.)

(Did this in CreateVstGuiFont. Maybe it would be better if this function took an enum
value for the fonts we support?)

Agh! It doesn't work. AddFontMemResourceEx succeeds but it looks like
it leaves the font not enumerable, and so when we try to load it by
name, that fails (like, we'd have to use the handle). Why is there no
option? Well, I guess we can write it to a temp file and load it with AddFontResourceExA... :/

Well, that also has problems, but I think I can make it basically work if
I maintain some data for the lifetime of the font (so I can pair RemoveFontResourceExA and
also delete the temp font file). Should be doable by moving this code from global functions in
dfxmisc to DfxGuiEditor members (we have this object wherever we need to create fonts).
Might be slightly overkill that we write a file and install a font every time the editor
opens and closes, but I think this is kinda par for the course on windows.

OK, so this is done, with (aside from being gross) has the remaining problem
that it sometimes leaves around the temp file. Unless this is due to a
CFontDesc lifetime bug, it's not clear how we would fix this, but it's
probably livable. On to the next!



Ugh, looks like there is some time between the font being registered
and VSTGUI being able to find it, like AddFontResource is not synchronous. :(
I didn't see this because the tracing message boxes inserted enough of
a delay.
I guess we could register the font much earlier (in editor constructor
rather than open()) which would "usually" work?
Is there some way to explicitly wait for the font to be available?


problems still:
 - dragging sliders and fine adjustments does do stuff to audio, but does not update ui
 - randomize button doesn't seem to do anything
   (see DfxGuiEditor::randomizeparameter(s) "missing implementations")
 - sometimes multiple copies of the plugin ui open up? And some are blank
      (This might just be a cakewalk bug! It happens if I double-click the plugin, I think because
       of my MessageBoxA modals which are preventing the plugin from opening until I OK them, so my
       second click opens another plugin window. I can actually get as many as I want this way. This
       would presumably not be a practical issue without the modals.)
 - sometimes everything just goes black, though the controls keep working (it's like we're not doing redraw() after the window gets obscured and then unconvered or something)
 - does picking presets work properly? Like "glup drums" did not sound gluppy.


"plugin turns black" problem

Some reference to this in DfxGuiEditor::idle maybe? That code actually
wasn't running because WINDOWS_VERSION is not defined (switched to
TARGET_OS_WIN32), but it didn't fix it.

I think this actually *only* happens after editing a parameter via
the textbox. So it could be a failure with that. But also note that this
is also currently the only kind of parameter change that seems to actually
be reflected in the UI, so it could also be a consequence of that problem?

.. in fact, this is very reproducible:
 - click a text param to edit it
 - click outside to cancel
 - click in it again. background disappears

switching directly between fields works fine. But once you cancel out, clicking on
the next text param loses the background.

BUT, if after clicking to cancel you drag a slider, then clicking on a text param is ok.

so the sequence required is
 - have an text param in edit mode
   - Exit via any of these of these:
      - click on background
      - click outside window
      - enter to confirm edit
   - But not these:
      - tab to drop focus (note that this seems to actually select the next control, which
        will always be a slider (try tab when the bg is black). so this exception is explained
        by the fact that slider interactions fix the state.
   - And then do NOT touch any other type of control
 - click on a text param

I think this is some kind of "dirty rectangles" thing where some code is not correctly
marking the background as dirty even though it got cleared. As you interact with other
controls (e.g. the sliders) you can start rebuilding the UI, as long as you don't
reactivate the bug. And exiting the text controls does repaint part of the background,
so it suggests that the background is repainted by tracking dirty regions.

indeed, there is some dirty rectangle tracking. note how CTextEdit calls invalid() in some
places, and then all the way up in CView we see

	/** check if view is dirty */
	virtual bool isDirty () const { return hasViewFlag (kDirty); }
	/** set the view to dirty so that it is redrawn in the next idle. Thread Safe ! */
	virtual void setDirty (bool val = true);
	/** if this is true, setting a view dirty will call invalid() instead of checking it in idle. Default value is false. */
	static bool kDirtyCallAlwaysOnMainThread;

	/** mark rect as invalid */
	virtual void invalidRect (const CRect& rect);
	/** mark whole view as invalid */
	virtual void invalid () { setDirty (false); invalidRect (getViewSize ()); }

so perhaps one way to "fix" this is to mark the whole frame as dirty in the problematic situation (i.e. whenever we take
focus). Perhaps CTextEdit is not calling invalid all the times that it should, but I can't figure out the theory of that
code.

Also suspicious is some of the DGControl wrapping. See for example:

void DGControl<T>::redraw()
{
//	T::invalid();  // XXX CView::invalid calls setDirty(false), which can have undesired consequences for control value handling
	T::invalidRect(T::getViewSize());
}

perhaps there are places where we should also be calling some base class method in our override, or some other
thing we're trying to do that's interfering with vstgui.

But in any case, marking the whole frame as dirty in a takeFocus override does solidly fix it (don't even get any
momentary flashing or anything), so I guess that's good enough for now. Should be harmless to redraw anyway,
as long as we're not like doing it every frame.
