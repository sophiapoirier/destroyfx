<!doctype html>


<head>

<title>Destroy FX Audio Unit utilities library</title>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

<style type="text/css" id="internalstyle">
	body
	{
		background: #C9FFE0 ;
		margin: 1.0em 1.2em ;
		font-family: "Lucida Grande", sans-serif ;
	}
	h1.bigsection
	{
		text-align: center ;
	}
	hr.bigsection
	{
		border-style: solid ;
		color: #808080 ;
	}
	p.footer
	{
		text-align: center ;
		font-size: 90% ;
	}
	.codesnippet
	{
		border: 1px dashed #663C22 ;
		background: #E9FFFF ;
		padding: 0.9em ;
		margin: 0 2.1em ;
	}
</style>

<meta name="description" content="A free, open source library for Audio Unit plugin development and hosting" />
<meta name="author" content="Sophia Poirier" />
<meta name="keywords" content="Destroy FX, DestroyFX, destroy fx, destroyfx, Audio Unit, AudioUnit, audio unit, audiounit, AU, Audio Units, AudioUnits, free, CoreAudio, coreaudio, Sophia Poirier, mac, macintosh, apple, macOS, Mac OS X, OS X, C, library, lib, CoreFoundation" />

</head>


<body>


<h1 class="bigsection">This is the home of the Destroy FX Audio Unit utilities library</h1>


<p><br /></p>
<h2>Introduction</h2>

<p>
Hello.  Here you will find information about a library of helpful functions for dealing with <a href="https://en.wikipedia.org/wiki/Audio_Units">Audio Units</a> in macOS, written by Sophia Poirier of <a href="http://destroyfx.org">Destroy FX</a>.  Currently, the library contains code that is useful for these things:
</p>
<ul>
	<li><a href="#preset_files">finding, loading, and saving AU preset files</a></li>
	<li><a href="#factory_presets_cfarray_callbacks">CFArray callbacks for Factory Presets arrays</a></li>
	<li><a href="#au_migrate_cfarray_callbacks">CFArray callbacks for AU Migrate arrays</a></li>
	<li><a href="#plugin_name_and_manufacturer_name">getting an AU's plugin name and manufacturer name</a></li>
	<li><a href="#comparing_component_descriptions">comparing ComponentDescriptions</a></li>
	<li><a href="#parameter_change_notification">posting parameter change notifications</a></li>
</ul>


<p><br /></p>
<h2>License</h2>

<p>
This library binary and source code are released under the terms of a <a href="bsd-license.txt">modified BSD License</a>.  It allows you to still use the library even if your project is not open source, although we still strongly encourage open source music software development.  The documentation (what you are looking at right now) is released under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation License</a>, with the exception of the example code snippets (in sections labeled &quot;programming example&quot;), which, like the other source code, are released under the terms of the same <a href="bsd-license.txt">modified BSD License</a>.
</p>

<!--
<pre id="license_text" style="border: 1px dashed black ; padding: 0.45em">
Copyright (C) 2003-2023  Sophia Poirier
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions 
are met:

*	Redistributions of source code must retain the above 
	copyright notice, this list of conditions and the 
	following disclaimer.
*	Redistributions in binary form must reproduce the above 
	copyright notice, this list of conditions and the 
	following disclaimer in the documentation and/or other 
	materials provided with the distribution.
*	Neither the name of Destroy FX nor the names of its 
	contributors may be used to endorse or promote products 
	derived from this software without specific prior 
	written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE 
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
OF THE POSSIBILITY OF SUCH DAMAGE.

To contact the author, please visit <a href="http://destroyfx.org">http://destroyfx.org</a> 
and use the contact form.
</pre>
-->


<p><br /></p>
<h2>How to get it</h2>

<p>
You can <a href="http://destroyfx.org/software/dfx-au-utilities-2020-11-29.bz2">download the packaged up distribution</a>.  It contains documentation, header files, a pre-built Mach-O library, resource files, and source files.  Since I might not always keep that perfectly up to date, you can always find the latest sources in the <a href="http://destroyfx.org/source.html">Destroy FX source repository</a>.
</p>
<p>
Please note that there are a lot of files in the repository, most of which are not a part of this library.  The files that comprise this library are located within the dfx-library directory and are the ones that start with dfx-au-utilities in their names and the ones in the {language-code}.lproj bundles (those are localized resource files, where {language-code} is an <a href="https://www.iso.org/iso-639-language-codes.html">ISO 639 language code</a>).
</p>


<p><br /></p>
<h2>How to use it</h2>

<p>
First, you are going to want to read the <a href="#documentation">documentation</a> for any part of the library that you are planning to utilize.  This section, however, contains some general info about how to incorporate the library into your project.
</p>

<p>
The simplest way to use the library is to #include "dfx-au-utilities.h" and link against the pre-built static library lib-dfx-au-utilities.a.  If you are using any of the AU preset file stuff in the library, you will also need to include the resource files that are in the localized {language-code}.lproj bundles (where {language-code} is an <a href="https://www.iso.org/iso-639-language-codes.html">ISO 639 language code</a>).  Those bundles contain localized string *.strings files.  I have named them in such a way that they should hopefully not clash with the names of anyone else's existing resource files.  Note that, if you rename these resource files, the library <b>will not work</b>, unless you also modify the source code to reference the new file names.
</p>

<p>
If you don't want to use the pre-built library, or if you want to make modifications to the source code, then instead of linking against the pre-built library, you will want to compile and link all of the *.c and *.m source files.  There is also a header file named dfx-au-utilities-private.h that contains an interface for the functions that are used by some of the functions defined in the primary interface.  If you're interested, you may want to check that stuff out, and perhaps you'll find something useful for your projects, in which case you can also #include "dfx-au-utilities-private.h" in your source code to be able to access and use those functions.  I am not going to really document that stuff, though, since I don't consider it to be the primary library interface, and I'd prefer to keep things simple and clean.
</p>

<p>
This library relies on some code in the AudioToolbox.framework and CoreFoundation.framework system frameworks, so if your project does not already link against those, then you will need to add them to your project.
</p>

<p>
This library presents a C API.  However, whenever possible (and sensible), transactions are done with <a href="https://developer.apple.com/documentation/CoreFoundation/">CoreFoundation</a> types.  This means that Objective C developers can easily utilize the code, since CF types are bridgeable between Carbon and Cocoa.
</p>


<p><br /></p>
<h2>Contact the author</h2>

<p>
There is a contact section at the bottom of <a href="http://destroyfx.org">destroyfx.org</a> if you wish to contact Sophia.  If you experience any problems with the library or make any interesting modifications, please let me know!  If you have a question about any of this stuff, please feel free to ask me; that way I know what is lacking or unclear in the documentation.
</p>






<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 id="documentation">Documentation</h1>

<p><a href="#preset_files">Finding, loading, and saving AU preset files</a></p>
<p><a href="#factory_presets_cfarray_callbacks">CFArray callbacks for Factory Presets arrays</a></p>
<p><a href="#au_migrate_cfarray_callbacks">CFArray callbacks for AU Migrate arrays</a></p>
<p><a href="#plugin_name_and_manufacturer_name">Getting an AU's plugin name and manufacturer name</a></p>
<p><a href="#comparing_component_descriptions">Comparing ComponentDescriptions</a></p>
<p><a href="#parameter_change_notification">Posting parameter change notifications</a></p>









<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="preset_files">Finding, loading, and saving AU preset files</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
In macOS, there are standardized locations for Audio Unit preset files:
</p>
<pre>
	~/Library/Audio/Presets/{manufacturer-name}/{plugin-name}
	/Library/Audio/Presets/{manufacturer-name}/{plugin-name}
</pre>
<p>
(where {manufacturer-name} is the first part of the name from the AudioComponent name string and {plugin-name} is the second part of that string)
</p>

<p>
In order to best take advantage of the benefits that users get from centralized and standardized plugin settings locations, every AU host should should make it easy for users to save to those locations and to access the preset files that are stored in those locations.  The user should not have to think about this issue; things should just work smoothly.  Otherwise, you can be sure that virtually no users will be going to the trouble of navigating to the proper standard folder, and then they will lose out.
</p>

<p>
Rather than simply proposing a solution and leaving it up to everyone to implement in their own way, I decided to just provide one that everyone can use.  Using this library, you can do things The Right Way&trade; with little effort.  There is a save function that provides a simple means for saving an AU's current state to a preset file in the proper location within the user domain, where user-authored files should go.  For finding and opening AU preset files, there is a function that you can call that will return a CFTree of all of the preset files for a given AU in a given file system domain.  You can use this to generate a menu of preset files, or whatever other sort of user interface works for your particular application.  (This side of things isn't as ready-made as the saving side of things, but that is because I don't want to pretend that I know how everyone's user interface could best present a collection of preset file names to the user.)  There is also a function for reading an AU preset file's data and applying it as the new state data for an AU instance.
</p>

<p>
I really think that it would be a big improvement if every host had behavior like this.  Users want an easy way to have their plugin settings accessible in all of their plugin host apps.  This gives them that.  Users don't want to always worry about where their files are being saved and always be asked to choose a location.  This gives them that.  It gives a clean, simple system with advantages of interoperability between hosts.
</p>


<p><br /></p>
<h3>Types</h3>

<p>
<a href="#DFXFileSystemDomain">DFXFileSystemDomain</a>
</p>

<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#SaveAUStateToPresetFile">SaveAUStateToPresetFile</a>
<br />
<a href="#SaveAUStateToPresetFile_Bundle">SaveAUStateToPresetFile_Bundle</a>
<br />
<a href="#CustomSaveAUPresetFile">CustomSaveAUPresetFile</a>
<br />
<a href="#CustomSaveAUPresetFile_Bundle">CustomSaveAUPresetFile_Bundle</a>
<br />
<br />
<a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a>
<br />
<a href="#GetCFURLFromFileURLsTreeNode">GetCFURLFromFileURLsTreeNode</a>
<br />
<a href="#CopyAUPresetNameFromCFURL">CopyAUPresetNameFromCFURL</a>
<br />
<a href="#RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</a>
<br />
<a href="#GetAUComponentDescriptionFromStateData">GetAUComponentDescriptionFromStateData</a>
<br />
<a href="#GetAUComponentDescriptionFromPresetFile">GetAUComponentDescriptionFromPresetFile</a>
<br />
<a href="#FindPresetsDirForAU">FindPresetsDirForAU</a>
<br />
<a href="#CFURLIsAUPreset">CFURLIsAUPreset</a>
</p>

<p><br /></p>
<h3>Constants</h3>

<p>
<a href="#DFXFileSystemDomain">kDFXFileSystemDomain_Local</a>
<br />
<a href="#DFXFileSystemDomain">kDFXFileSystemDomain_User</a>
</p>

<p>
To give you a better understanding of the purposes of these functions, here's what I think the ideal host behavior might be, using these functions:
</p>

<p>
For each instanciated AU, the host offers a menu for preset file stuff.  The first item in the menu says &quot;Save Preset File...&quot;  When the user chooses that menu item, the host presents some UI to allow the user to specify a name for the preset and then with that calls <a href="#SaveAUStateToPresetFile">SaveAUStateToPresetFile</a>.
</p>

<p>
The host calls <a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a> for each relevant <a href="#DFXFileSystemDomain">file system domain</a>:  kDFXFileSystemDomain_User and kDFXFileSystemDomain_Local.  For each one that returns a valid CFTree, the host creates a sub-menu item accordingly:  &quot;User presets&quot; and &quot;Local presets&quot;.  The host populates those sub-menus by walking through the respective trees.  For each node in the tree, the host uses <a href="#GetCFURLFromFileURLsTreeNode">GetCFURLFromFileURLsTreeNode</a> to get the CFURL for that tree node.  For each file CFURL in the tree, the host uses <a href="#CopyAUPresetNameFromCFURL">CopyAUPresetNameFromCFURL</a> to get a CFString to use as the text for that menu item.  For each sub-directory CFURL in the tree, the host uses CFURLCopyLastPathComponent to get a CFString to use as the text for that menu item, and makes that menu item another sub-menu for all of the children of that tree node.  Now the sub-menus are complete.  When the user chooses any one of the preset files from these sub-menus, the host uses <a href="#RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</a> to load that file in the AU.
</p>

<p>
Finally, there is one more item in this menu:  &quot;Load Preset File...&quot;  When the user chooses that item, the host presents a file open dialog whose initial location is set using <a href="#FindPresetsDirForAU">FindPresetsDirForAU</a>, and whose selectable file filter relies upon <a href="#CFURLIsAUPreset">CFURLIsAUPreset</a>, and then uses <a href="#RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</a> to load that selected file in the AU.
</p>




<p><br /></p>
<hr />

<h2 id="DFXFileSystemDomain">DFXFileSystemDomain</h2>

<pre>
typedef enum
{
	kDFXFileSystemDomain_Local,
	kDFXFileSystemDomain_User
} DFXFileSystemDomain
</pre>


<p><br /></p>
<h3>explanation</h3>

<p>
The macOS file system is split into "domains", and the two domains handled in some of this library's functions are "local" and "user".  The local domain is for non-system files that are globally shared by all users of a computer (location is relative to / the root of the system hard disk).  The user domain is for files encapsulated only within a given user account (location is relative to ~/ the root of the user account directory).
</p>




<p><br /></p>
<hr />

<h2 id="SaveAUStateToPresetFile">SaveAUStateToPresetFile</h2>

<p><code>
OSStatus SaveAUStateToPresetFile(AudioComponentInstance inAUComponentInstance, CFStringRef inAUPresetNameString, CFURLRef* outSavedAUPresetFileURL, Boolean inPromptToReplaceFile)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose state data (ClassInfo AU property) you want to write out to a preset file.
</p>

<p>
<var>inAUPresetNameString</var><br />
The name to use for the saved AU preset file.
</p>

<p>
<var>outSavedAUPresetFileURL</var><br />
Upon successful return, this may point to a CFURLRef that references the file to which the data was saved.  Can be NULL.
</p>

<p>
<var>inPromptToReplaceFile</var><br />
Whether a dialog will be presented asking the user before replacing the existing file, if a file already exists at the save location.
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  If the user was asked whether to replace an existing file and chose not to, then userCanceledErr is returned.  If the AU's state data could not be retrieved, then the error code will be whatever the AU itself or the OS returned.  If there was an error writing the data to disk, then the error code will be whatever CFURL error was returned when attempting the operation.  If there was a problem finding the standard location for the AU for saving the file, then an appropriate error code will be returned.  If any necessary CoreFoundation objects could not be created, then coreFoundationUnknownErr is returned.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This is the function that you use when the user wants to export a preset file for an AU to disk.  It always saves to the "user" file system domain.
</p>
<p>
You do not need to add the .aupreset file name extension to the preset name.  It will be automatically appended for the output file name.  But if the you did include the .aupreset extension, that will be noted and nothing extra will be appended.
</p>
<p>
If the file name is too long, it will be truncated (before appending the .aupreset extension, so the extension is always complete).
</p>
<p>
The caller is responsible for releasing inAUPresetNameString when done with it.  <a href="#SaveAUStateToPresetFile">SaveAUStateToPresetFile</a> does not consume a reference to inAUPresetNameString, nor is it retained.
</p>
<p>
This function sets the value of the kAUPresetNameKey in the saved preset dictionary to name that the user enters as the file name.  This is the expected behavior when saving AU preset files.
</p>
<p>
If you are interested in knowing to which file the AU state data was saved, you can provide a valid pointer to a CFURLRef for the outSavedAUPresetFileURL argument.  If you are not interested, pass in NULL for outSavedAUPresetFileURL.  But please note that it might be the case that no valid reference is available before this function returns.  Therefore, if you do pass in a valid reference to a CFURLRef for the outSavedAUPresetFileURL argument, the you should first null the CFURLRef.  If the function returns successfully, you still must check to see if your CFURLRef is still null in order to determine if the CFURL was able to be provided.  If the CFURL is not null, then you own a reference to it and are responsible for releasing it when done with it.
</p>
<p>
Similarly, it may not be possible to get the CFURL of the saved file.  Again, if the caller passes a reference to a CFURLRef for the outSavedAUPresetFileURL argument, the caller should first null the CFURLRef, since it might be the case that no valid reference is available before this function returns.
</p>
<p>
When you call this function, the resources for any dialog are searched for in the main application bundle.  If you are hosting an Audio Unit but are not the running application (or you are the Audio Unit itself), you need to call the <a href="#SaveAUStateToPresetFile_Bundle">SaveAUStateToPresetFile_Bundle</a> function instead so that you can specify the bundle where the resources can be found.
</p>




<p><br /></p>
<hr />

<h2 id="SaveAUStateToPresetFile_Bundle">SaveAUStateToPresetFile_Bundle</h2>

<p><code>
OSStatus SaveAUStateToPresetFile_Bundle(AudioComponentInstance inAUComponentInstance, CFStringRef inAUPresetNameString, CFURLRef* outSavedAUPresetFileURL, Boolean inPromptToReplaceFile, CFBundleRef inBundle)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose state data (ClassInfo AU property) you want to write out to a preset file.
</p>

<p>
<var>inAUPresetNameString</var><br />
The name to use for the saved AU preset file.
</p>

<p>
<var>outSavedAUPresetFileURL</var><br />
Upon successful return, this may point to a CFURLRef that references the file to which the data was saved.  Can be NULL.
</p>

<p>
<var>inPromptToReplaceFile</var><br />
Whether a dialog will be presented asking the user before replacing the existing file, if a file already exists at the save location.
</p>

<p>
<var>inBundle</var><br />
A reference to the bundle where the dialog resources can be found.  If NULL, then the main application bundle is used.
</p>

<p>
<i><b>result</b></i><br />
A status code, the same as with <a href="#SaveAUStateToPresetFile">SaveAUStateToPresetFile</a>.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This is a variant of <a href="#SaveAUStateToPresetFile">SaveAUStateToPresetFile</a> that allows you to specify the bundle where the dialog resources are located.  You should use this function if you are calling from some plugin or framework or anything other than the running application.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example of how an AU View might use this function to load a preset file for its associated Audio Unit:
</p>

<pre class="codesnippet">
CFBundleRef const pluginBundle = CFBundleGetBundleWithIdentifier(CFSTR("org.destroyfx.MegaEffect"));
if (pluginBundle != NULL)
{
	CFURLRef savedFileURL = NULL;
	OSStatus const status = SaveAUStateToPresetFile_Bundle(GetEditAudioUnit(), NULL, &amp;savedFileURL, pluginBundle);
	if ((status == noErr) &amp;&amp; (savedFileURL != NULL))
	{
		CFShow(savedFileURL);	/* print info about the saved file's URL to stderr */
		CFRelease(savedFileURL);
	}
}
</pre>




<p><br /></p>
<hr />

<h2 id="CustomSaveAUPresetFile">CustomSaveAUPresetFile</h2>

<p><code>
OSStatus CustomSaveAUPresetFile(AudioComponentInstance inAUComponentInstance, CFURLRef inAUPresetFileURL, Boolean inPromptToReplaceFile)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose state data (ClassInfo AU property) you want to write out to a preset file.
</p>

<p>
<var>inAUPresetFileURL</var><br />
The file path where you wish to save the AU preset file.
</p>

<p>
<var>inPromptToReplaceFile</var><br />
Whether a dialog will be presented asking the user before replacing the existing file, if a file already exists at the save location.
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  If the user was asked whether to replace an existing file and chose not to, then userCanceledErr is returned.  If the AU's state data could not be retrieved, then the error code will be whatever the AU itself or the OS returned.  If there was an error writing the data to disk, then the error code will be whatever CFURL error was returned when attempting the operation.  If any necessary CoreFoundation objects could not be created, then coreFoundationUnknownErr is returned.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This function can save a preset file for an AU to a non-default location on disk.
</p>
<p>
You do not need to add the .aupreset file name extension to the preset name.  It will be automatically appended for the output file name.  But if the you did include the .aupreset extension, that will be noted and nothing extra will be appended.
</p>
<p>
If the file name is too long, it will be truncated (before appending the .aupreset extension, so the extension is always complete).
</p>
<p>
The caller is responsible for releasing inAUPresetNameString when done with it.  <a href="#CustomSaveAUPresetFile">CustomSaveAUPresetFile</a> does not consume a reference to inAUPresetNameString, nor is it retained.
</p>
<p>
This function sets the value of the kAUPresetNameKey in the saved preset dictionary to name that the user enters as the file name.  This is the expected behavior when saving AU preset files.
</p>
<p>
When you call this function, the resources for any dialog are searched for in the main application bundle.  If you are hosting an Audio Unit but are not the running application (or you are the Audio Unit itself), you need to call the <a href="#CustomSaveAUPresetFile_Bundle">CustomSaveAUPresetFile_Bundle</a> function instead so that you can specify the bundle where the resources can be found.
</p>




<p><br /></p>
<hr />

<h2 id="CustomSaveAUPresetFile_Bundle">CustomSaveAUPresetFile_Bundle</h2>

<p><code>
OSStatus CustomSaveAUPresetFile_Bundle(AudioComponentInstance inAUComponentInstance, CFURLRef inAUPresetFileURL, Boolean inPromptToReplaceFile, CFBundleRef inBundle)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose state data (ClassInfo AU property) you want to write out to a preset file.
</p>

<p>
<var>inAUPresetFileURL</var><br />
The file path where you wish to save the AU preset file.
</p>

<p>
<var>inPromptToReplaceFile</var><br />
Whether a dialog will be presented asking the user before replacing the existing file, if a file already exists at the save location.
</p>

<p>
<var>inBundle</var><br />
A reference to the bundle where the dialog resources can be found.  If NULL, then the main application bundle is used.
</p>

<p>
<i><b>result</b></i><br />
A status code, the same as with <a href="#CustomSaveAUPresetFile">CustomSaveAUPresetFile</a>.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This is a variant of <a href="#CustomSaveAUPresetFile">CustomSaveAUPresetFile</a> that allows you to specify the bundle where the dialog resources are located.  You should use this function if you are calling from some plugin or framework or anything other than the running application.
</p>




<p><br /></p>
<hr />

<h2 id="CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</h2>

<p><code>
CFTreeRef CFTreeCreateFromAUPresetFilesInDomain(AudioComponent inAUComponent, DFXFileSystemDomain inFileSystemDomain)
</code></p>

<p>
<var>inAUComponent</var><br />
The AU Component whose preset files you want to find.
</p>

<p>
<var>inFileSystemDomain</var><br />
The <a href="#DFXFileSystemDomain">file system domain</a> constant for the domain that you want to search in for preset files.
</p>

<p>
<i><b>result</b></i><br />
A CFTree with the complete hierarchy of preset files and sub-directories for the given AU and domain.  The root tree is for the root directory containing the preset files.  If no preset files are found or if an error occurs, the result will be NULL.  The <i>info</i> field of each tree node's CFTreeContext is a CFURLRef for the preset file or sub-directory.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This is the function that you use when you want to find out what AU preset files exist on the user's system.  In order to find everything in the user's presets collection, you will want to do this for each possible <a href="#DFXFileSystemDomain">file system domain</a>:  kDFXFileSystemDomain_User and kDFXFileSystemDomain_Local.
</p>
<p>
The caller owns a reference to the CFTree.  You should CFRelease it when you are done.  When you do that, all child trees and contained CFURLs will be released.  The CFURLRef in each tree node is valid for the lifespan of the returned CFTree object.  If you are going to release the tree, you should first retain any CFURLs that you still want to be able to access.
</p>
<p>
If you want an easy way to fetch the CFURL for a given tree node, you can use <a href="#GetCFURLFromFileURLsTreeNode">GetCFURLFromFileURLsTreeNode</a>.
</p>
<p>
If any sub-directory contains no preset files, then it gets pruned from the tree before this function returns, so you don't need to check for empty branches.
</p>
<p>
If you want to know whether a given tree node is a reference to a preset file or a sub-directory of preset files, simply check to see if it has any children with CFTreeGetChildCount.  If the return count value is greater than zero, then that means that the tree node references a sub-directory; otherwise, it references a file.
</p>
<p>
If you want to get a nicely displayable name string for a given preset file CFURL (like for the text in a menu entry, without its parent directory path prefixed and without the .aupreset file name extension), you can use <a href="#CopyAUPresetNameFromCFURL">CopyAUPresetNameFromCFURL</a>.  If you want to do the same thing for a sub-directory CFURL, simply use the CFURLCopyLastPathComponent function (which is part of the regular CoreFoundation API).
</p>
<p>
<!--
Note that, currently, this function only checks each file found to determine if it is an AU preset type file, based on its file name extension (.aupreset).  It does not examine the data in the file to determine whether it is valid AU state data, or if it is state data for the specified AU.  It is assumed that any AU preset files in the standard locations for the AU will be valid for that AU.  I might refine this more in the future, though.
-->
This function checks each file found to determine if it is an AU preset type file, based on its file name extension (.aupreset).  It also examines the data in the file to determine whether it is valid AU state data for the specified AU (i.e. the identifying values must match the AU's AudioComponentDescription, which is determined by using <a href="#ComponentAndDescriptionMatch_Loosely">ComponentAndDescriptionMatch_Loosely</a>).  Any files that don't pass either of these examinations are excluded from the tree.  There should not ever be preset files for the wrong AU in the standard locations, but just in case there are, they will be excluded.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example recursive function that walks through the CFTree hierarchy, looks at each node and determines if it's a file or sub-directory, gets the CFURLRef for each node, and uses CFShow to print a description of the CFURL to stderr:
</p>

<pre class="codesnippet">
void ShowTree(CFTreeRef inTree)
{
	if (inTree == NULL)
	{
		fprintf(stderr, "tree is null!\n");
	}
	else
	{
		if (CFTreeGetChildCount(inTree) &gt; 0)
		{
			fprintf(stderr, "this tree node represents a sub-directory of preset files\n");
		}
		else
		{
			fprintf(stderr, "this tree node represents a preset file\n");
		}
		CFURLRef const treeItemURL = GetCFURLFromFileURLsTreeNode(inTree);
		CFShow(treeItemURL);
		CFTreeRef const child = CFTreeGetFirstChild(inTree);
		if (child != NULL)
		{
			ShowTree(child);
		}
		CFTreeRef const next = CFTreeGetNextSibling(inTree);
		if (next != NULL)
		{
			ShowTree(next);
		}
	}
}
</pre>


<p>
And here's an example of using the above function to find all of the AU preset files in each valid file system domain, for a given AU Component:
</p>

<pre class="codesnippet">
fprintf(stderr, "\n\tlooking in the user domain for preset files...\n");
CFTreeRef auPresetsTree = CFTreeCreateFromAUPresetFilesInDomain(someAUComponent, kDFXFileSystemDomain_User);
ShowTree(auPresetsTree);
if (auPresetsTree != NULL)
{
	CFRelease(auPresetsTree);
}

fprintf(stderr, "\n\tlooking in the local domain for preset files...\n");
auPresetsTree = CFTreeCreateFromAUPresetFilesInDomain(someAUComponent, kDFXFileSystemDomain_Local);
ShowTree(auPresetsTree);
if (auPresetsTree != NULL)
{
	CFRelease(auPresetsTree);
}
</pre>



<p><br /></p>
<hr />

<h2 id="GetCFURLFromFileURLsTreeNode">GetCFURLFromFileURLsTreeNode</h2>

<p><code>
CFURLRef GetCFURLFromFileURLsTreeNode(CFTreeRef inTree)
</code></p>

<p>
<var>inTree</var><br />
A CFTreeRef that holds a CFURLRef in the <i>info</i> field of its CFTreeContext.
</p>

<p>
<i><b>result</b></i><br />
The CFURLRef that is contained in the input tree, or NULL if something goes wrong.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
You use this function when you want to access one of the files or sub-directories in the tree that is returned by <a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a>.  The file or sub-directory CFURL reference is contained in the <i>info</i> field of each tree node's CFTreeContext structure.  Since there's no very quick and convenient way to access that tree data pointer, I wrote this function to make it easy.
</p>
<p>
This function simply returns the pointer value without retaining the CFURL.  The tree owns a reference to the CFURL.  If you need to keep a reference to the CFURL beyond the life of its owner tree, then you are responsible for retaining it and then releasing it when you are done.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</a> for a usage example.
</p>




<p><br /></p>
<hr />

<h2 id="CopyAUPresetNameFromCFURL">CopyAUPresetNameFromCFURL</h2>

<p><code>
CFStringRef CopyAUPresetNameFromCFURL(CFURLRef inAUPresetFileURL)
</code></p>

<p>
<var>inAUPresetFileURL</var><br />
A CFURLRef representing an AU preset file.
</p>

<p>
<i><b>result</b></i><br />
A CFStringRef that has the name of the file represented by the input file without the .aupreset file name extension.  If anything goes wrong, the result is NULL.  If the input CFURL does not represent a file with an extension, then I'm not sure what happens, whatever happens when you do that with CFURLCreateCopyDeletingPathExtension.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This is a convenience function for getting a more user-friendly display text of an AU preset file from a CFURL reference to the file.  It removes the parent directory path and the .aupreset file name extension, returning only the name of the file without file name extension.  You will probably want to use this function when generating a user interface to the preset files in the user's collection.
</p>
<p>
The caller owns a reference to the returned CFString and is responsible for releasing it when done.
</p>

<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example that iterates through every sibling in one level of a preset files tree and uses the readable name from <a href="#CopyAUPresetNameFromCFURL">CopyAUPresetNameFromCFURL</a> to set the text of each item in a menu:
</p>

<pre class="codesnippet">
CFIndex const numChildren = CFTreeGetChildCount(parentTree);
SetControlMaximum(yourMenuControl, numChildren);
CFTreeRef presetFileTreeNode = CFTreeGetFirstChild(parentTree);
for (CFIndex i = 0; i &lt; numChildren; i++)
{
	CFURLRef const theFile = GetCFURLFromFileURLsTreeNode(presetFileTreeNode);
	CFStringRef itemName = NULL;
	/* it's a sub-directory of preset files */
	if (CFTreeGetChildCount(presetFileTreeNode) &gt; 0)
	{
		itemName = CFURLCopyLastPathComponent(theFile);
	}
	/* it's a preset file */
	else
	{
		itemName = CopyAUPresetNameFromCFURL(theFile);
	}
	if (itemName != NULL)
	{
		SetMenuItemTextWithCFString(yourMenu, i + 1, itemName);
		CFRelease(itemName);
	}
	presetFileTreeNode = CFTreeGetNextSibling(presetFileTreeNode);
}
</pre>




<p><br /></p>
<hr />

<h2 id="RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</h2>

<p><code>
OSStatus RestoreAUStateFromPresetFile(AudioComponentInstance inAUComponentInstance, CFURLRef inAUPresetFileURL)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose state data (ClassInfo AU property) you want to restore from a preset file on disk.
</p>

<p>
<var>inAUPresetFileURL</var><br />
A CFURLRef that references the AU preset file that contains the AU state data that you would like to restore.
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  If the AU's state data could not be restored, then the error code will be whatever the AU itself or the OS returned.  If there was an error reading the data from disk, then the error code will be whatever CFURL error was returned when attempting the operation.  If the file's data was not valid XML data that could be translated into a CFPropertyList, then coreFoundationUnknownErr or whatever error code was encountered during that operation is returned.
</p>

<p><br /></p>
<h3>explanation</h3>
<p>
This is the function that you would use to get the data from an AU preset file and set that as the current state of an Audio Unit.  For example, you might call this after you have used <a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a> to get a tree of the user's preset files collection, presented that collection to the user, and then the user indicated that she wanted to load one of those presets.
</p>
<p>
The caller is responsible for releasing inAUPresetFileURL when done with it.  <a href="#RestoreAUStateFromPresetFile">RestoreAUStateFromPresetFile</a> does not consume a reference to inAUPresetFileURL, nor is it retained.
</p>

<p><br /></p>
<h3>programming example</h3>

<p>
</p>

<pre class="codesnippet">
CFTreeRef const auPresetsTree = CFTreeCreateFromAUPresetFilesInDomain(AudioComponentInstanceGetComponent(someAUInstance), kDFXFileSystemDomain_User);
/* ...do something here to present the tree to the user... */
/* ...the user chooses a file... */
/* ...get the tree node corresponding to that file... */
CFURLRef const theFile = GetCFURLFromFileURLsTreeNode(presetTreeNode);
OSStatus const status = RestoreAUStateFromPresetFile(someAUInstance, theFile);
</pre>




<p><br /></p>
<hr />

<h2 id="GetAUComponentDescriptionFromStateData">GetAUComponentDescriptionFromStateData</h2>

<p><code>
OSStatus GetAUComponentDescriptionFromStateData(CFPropertyListRef inAUStateData, AudioComponentDescription* outComponentDescription)
</code></p>

<p>
<var>inAUStateData</var><br />
A CFPropertyListRef containing an AU state data dictionary.
</p>

<p>
<var>outComponentDescription</var><br />
Upon successful return, this structure's type, sub-type, and manufacturer ID values will be set to those found in the AU preset file's data (and the other values in the structure will be set to zero).
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  Possible error code is kAudioUnitErr_InvalidPropertyValue if the dictionary is not in the expected format or is missing any of the required keys, or if the dictionary's value for kAUPresetVersionKey is unrecognized.
</p>

<p><br /></p>
<h3>explanation</h3>

<p>
AU state data is stored in the form of a CFDictionary.  The dictionary is expected to contain values for the type, sub-type, and manufacturer IDs of the specific AU that created the data.  This is in order to specify which AU is able read the data.  This function collects those identifying values from an AU state data dictionary into an AudioComponentDescription, providing a simple way to identify the data's creator.
</p>

<p>
This function is used internally by <a href="#GetAUComponentDescriptionFromPresetFile">GetAUComponentDescriptionFromPresetFile</a> to process the data contained in an AU preset file.  Since it may also be useful in other contexts, I made it one of the public functions of this library.
</p>




<p><br /></p>
<hr />

<h2 id="GetAUComponentDescriptionFromPresetFile">GetAUComponentDescriptionFromPresetFile</h2>

<p><code>
OSStatus GetAUComponentDescriptionFromPresetFile(CFURLRef inAUPresetFileURL, AudioComponentDescription* outComponentDescription)
</code></p>

<p>
<var>inAUPresetFileURL</var><br />
A CFURLRef representing an AU preset file.
</p>

<p>
<var>outComponentDescription</var><br />
Upon successful return, this structure's type, sub-type, and manufacturer ID values will be set to those found in the AU preset file's data (and the other values in the structure will be set to zero).
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  Possible error codes are those returned by CreatePropertyListFromXMLFile or <a href="#GetAUComponentDescriptionFromStateData">GetAUComponentDescriptionFromStateData</a>.
</p>

<p><br /></p>
<h3>explanation</h3>

<p>
This is a variant of <a href="#GetAUComponentDescriptionFromStateData">GetAUComponentDescriptionFromStateData</a> that allows you to start with a file reference to an AU preset file and then retrieve the identifying values of the contained AU state data's creator.  It is a convenience function that takes care of reading the XML data from the AU preset file, and then from there does the same thing as <a href="#GetAUComponentDescriptionFromStateData">GetAUComponentDescriptionFromStateData</a>.
</p>

<p>
This function is used internally by <a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a> when it validates an AU preset file's data to see if its identifying values match those of the specified AU.  Since it may also be useful in other contexts, I made it one of the public functions of this library.
</p>




<p><br /></p>
<hr />

<h2 id="FindPresetsDirForAU">FindPresetsDirForAU</h2>

<p><code>
CFURLRef FindPresetsDirForAU(AudioComponent inAUComponent, DFXFileSystemDomain inFileSystemDomain, Boolean inCreateDir)
</code></p>

<p>
<var>inAUComponent</var><br />
The AU Component whose preset files location you seek.
</p>

<p>
<var>inFileSystemDomain</var><br />
The <a href="#DFXFileSystemDomain">file system domain</a> constant for the domain that you want to search in for preset files.
</p>

<p>
<var>inCreateDir</var><br />
Whether any path directory components should be created if not already present.
</p>

<p>
<i><b>result</b></i><br />
A directory URL:  a CFURL of the correct directory for preset files for the particular AU, or null if any error occurred.
</p>

<p><br /></p>
<h3>explanation</h3>

<p>
Based upon the specific AU component provided and the requested file system domain, this function will return the correct location for preset files for that AU within the given domain.  If that directory path does not already exist, requesting to create any directories necessary to complete the path will attempt to do that.  Without specifying creation, it is possible that the returned path does not actually fully exist.
</p>




<p><br /></p>
<hr />

<h2 id="CFURLIsAUPreset">CFURLIsAUPreset</h2>

<p><code>
Boolean CFURLIsAUPreset(CFURLRef inURL)
</code></p>

<p>
<var>inURL</var><br />
Any CFURLRef.
</p>

<p>
<i><b>result</b></i><br />
A boolean answer: TRUE if the CFURL is an AU preset file, otherwise FALSE.
</p>

<p><br /></p>
<h3>explanation</h3>

<p>
This function determines whether the CFURL represents a file and has the filename extension expected of AU preset files.
</p>









<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="factory_presets_cfarray_callbacks">CFArray callbacks for Factory Presets arrays</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
CFArrays use a set of callbacks that define what happens to their contained data items when you retain the array, release the array, ask to compare two items in the array, or ask for a description of an item in the array.  When the data items that an array holds are all CF types, there are standard CF ways to handle all of these situations and a convenient pre-made global CFArray callbacks structure that gives you that behavior (kCFTypeArrayCallBacks).  In the AU API, though, you need to make CFArrays of non-CF type data when you support the kAudioUnitProperty_FactoryPresets property.  So for those arrays, you need to define custom callbacks that will properly handle pointers to AUPreset structures as their data items.  The lifespan of the array may be greater than the lifespan of the plugin and any of its AUPreset data, so you must ensure proper memory management of the AUPreset data items when the CFArray is retained and released.  That is what my callbacks do, which can be used via the kCFAUPresetArrayCallBacks constant.
</p>

<p>
Using these callbacks also requires the use of an object that can encompass an AUPreset structure but also hold the necessary extra data to mimic CFType behavior.  That is the purpose of the CFAUPresetRef type.  It is an opaque type and so there are functions for handling it correctly.  You must use the Factory Preset array callbacks in this library only with this data type.
</p>


<p><br /></p>
<h3>Types</h3>

<p>
<a href="#CFAUPresetRef">CFAUPresetRef</a>
</p>

<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#CFAUPresetCreate">CFAUPresetCreate</a>
<br />
<a href="#CFAUPresetRetain">CFAUPresetRetain</a>
<br />
<a href="#CFAUPresetRelease">CFAUPresetRelease</a>
</p>

<p><br /></p>
<h3>Constants</h3>

<p>
<a href="#kCFAUPresetArrayCallBacks">kCFAUPresetArrayCallBacks</a>
</p>




<p><br /></p>
<hr />

<h2 id="CFAUPresetRef">CFAUPresetRef</h2>

<p><code>
typedef struct CFAUPreset const* CFAUPresetRef
</code></p>


<p><br /></p>
<h3>explanation</h3>

<p>
CFAUPreset is an opaque type that contains an AUPreset structure.  It is a wrapper-type object designed to be able to mimic CoreFoundation object behavior for the AUPreset structure.
</p>
<p>
Please note that CFAUPreset is not a CFType, and therefore CFAUPresetRef is not compatible with any common CoreFoundation functions (like CFRetain, CFRelease, etc.).  The functions contained in this library are the only ones that you can use with a CFAUPresetRef.
</p>
<p>
A CFAUPresetRef can be cast to AUPreset*, but the same is not true for the reverse.
</p>




<p><br /></p>
<hr />

<h2 id="CFAUPresetCreate">CFAUPresetCreate</h2>

<p><code>
CFAUPresetRef CFAUPresetCreate(CFAllocatorRef inAllocator, SInt32 inPresetNumber, CFStringRef inPresetName)
</code></p>

<p>
<var>inAllocator</var><br />
The allocator to use to allocate the memory via CFAllocatorAllocate.
</p>

<p>
<var>inPresetNumber</var><br />
The value that you want set as the presetNumber value in the AUPreset.
</p>

<p>
<var>inPresetName</var><br />
The string that you want used as the presetName value in the AUPreset.
</p>

<p>
<i><b>result</b></i><br />
A reference to a newly allocated CFAUPreset object containing an AUPreset with its fields set to the values as passed into this function.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function will allocate an instance of a CFAUPreset object and initialize the value fields of its contained AUPreset structure according to the corresponding arguments of the function.
</p>
<p>
The caller owns a reference to the returned CFAUPresetRef and is responsible for releasing it when done.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example implementation of an AUBase-derived AU's GetPresets() method:
</p>

<pre class="codesnippet">
OSStatus MegaEffect::GetPresets(CFArrayRef* outData) const
{
	// simply a query to see if the property is supported
	if (!outData)
	{
		return noErr;
	}

	CFMutableArrayRef const presetsArray = CFArrayCreateMutable(kCFAllocatorDefault, 2, &amp;kCFAUPresetArrayCallBacks);
	if (!presetsArray)
	{
		*outData = nullptr;
		return coreFoundationUnknownErr;
	}

	if (CFAUPresetRef const preset = CFAUPresetCreate(kCFAllocatorDefault, 1, CFSTR("a preset")))
	{
		CFArrayAppendValue(presetsArray, preset);
		CFAUPresetRelease(preset);
	}

	if (CFAUPresetRef const preset = CFAUPresetCreate(kCFAllocatorDefault, 2, CFSTR("another preset")))
	{
		CFArrayAppendValue(presetsArray, preset);
		CFAUPresetRelease(preset);
	}

	*outData = reinterpret_cast&lt;CFArrayRef&gt;(presetsArray);
	return noErr;
}
</pre>




<p><br /></p>
<hr />

<h2 id="CFAUPresetRetain">CFAUPresetRetain</h2>

<p><code>
CFAUPresetRef CFAUPresetRetain(CFAUPresetRef inPreset)
</code></p>

<p>
<var>inPreset</var><br />
A reference to a CFAUPreset object to be retained.
</p>

<p>
<i><b>result</b></i><br />
A reference to the CFAUPreset object that was retained.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function mimics the behavior of CFRetain, but specifically for the CFAUPresetRef type and not any CFTypeRef.
</p>



<p><br /></p>
<hr />

<h2 id="CFAUPresetRelease">CFAUPresetRelease</h2>

<p><code>
void CFAUPresetRelease(CFAUPresetRef inPreset)
</code></p>

<p>
<var>inPreset</var><br />
A reference to a CFAUPreset object to be released.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function mimics the behavior of CFRelease, but specifically for the CFAUPresetRef type and not any CFTypeRef.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUPresetCreate">CFAUPresetCreate</a> for a relevant example.
</p>



<p><br /></p>
<hr />

<h2 id="kCFAUPresetArrayCallBacks">kCFAUPresetArrayCallBacks</h2>

<p><code>
CFArrayCallBacks const kCFAUPresetArrayCallBacks
</code></p>


<p><br /></p>
<h3>explanation</h3>

<p>
This CFArrayCallbacks structure is initialized (when your code is loaded) to contain pointers to callbacks that will correctly handle retaining, releasing, comparing, and describing CFArrays that contain <a href="#CFAUPresetRef">CFAUPresetRef</a> instances as their data items.  You can pass this for the CFArrayCallbacks* argument when creating arrays with CFArrayCreate or CFArrayCreateMutable.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUPresetCreate">CFAUPresetCreate</a> for a relevant example.
</p>









<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="au_migrate_cfarray_callbacks">CFArray callbacks for AU Migrate arrays</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
CFArrays use a set of callbacks that define what happens to their contained data items when you retain the array, release the array, ask to compare two items in the array, or ask for a description of an item in the array.  When the data items that an array holds are all CF types, there are standard CF ways to handle all of these situations and a convenient pre-made global CFArray callbacks structure that gives you that behavior (kCFTypeArrayCallBacks).  In the AU API, though, you need to make CFArrays of non-CF type data when you support the kAudioUnitMigrateProperty_FromPlugin property.  So for those arrays, you need to define custom callbacks that will properly handle pointers to AudioUnitOtherPluginDesc structures as their data items.  The lifespan of the array may be greater than the lifespan of the plugin and any of its AudioUnitOtherPluginDesc data, so you must ensure proper memory management of the AudioUnitOtherPluginDesc data items when the CFArray is retained and released.  That is what my callbacks do, which can be used via the kCFAUOtherPluginDescArrayCallBacks constant.
</p>

<p>
Using these callbacks also requires the use of an object that can encompass an AudioUnitOtherPluginDesc structure but also hold the necessary extra data to mimic CFType behavior.  That is the purpose of the CFAUOtherPluginDescRef type.  It is an opaque type and so there are functions for handling it correctly.  You must use the AU Migrate array callbacks in this library only with this data type.
</p>


<p><br /></p>
<h3>Types</h3>

<p>
<a href="#CFAUOtherPluginDescRef">CFAUOtherPluginDescRef</a>
</p>

<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#CFAUOtherPluginDescCreate">CFAUOtherPluginDescCreate</a>
<br />
<a href="#CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</a>
<br />
<a href="#CFAUOtherPluginDescCreateMAS">CFAUOtherPluginDescCreateMAS</a>
<br />
<a href="#CFAUOtherPluginDescRetain">CFAUOtherPluginDescRetain</a>
<br />
<a href="#CFAUOtherPluginDescRelease">CFAUOtherPluginDescRelease</a>
</p>

<p><br /></p>
<h3>Constants</h3>

<p>
<a href="#kCFAUOtherPluginDescArrayCallBacks">kCFAUOtherPluginDescArrayCallBacks</a>
</p>




<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescRef">CFAUOtherPluginDescRef</h2>

<p><code>
typedef struct CFAUOtherPluginDesc const* CFAUOtherPluginDescRef
</code></p>


<p><br /></p>
<h3>explanation</h3>

<p>
CFAUOtherPluginDesc is an opaque type that contains an AudioUnitOtherPluginDesc structure.  It is a wrapper-type object designed to be able to mimic CoreFoundation object behavior for the AudioUnitOtherPluginDesc structure.
</p>
<p>
Please note that CFAUOtherPluginDesc is not a CFType, and therefore CFAUOtherPluginDescRef is not compatible with any common CoreFoundation functions (like CFRetain, CFRelease, etc.).  The functions contained in this library are the only ones that you can use with a CFAUOtherPluginDescRef.
</p>
<p>
A CFAUOtherPluginDescRef can be cast to AudioUnitOtherPluginDesc*, but the same is not true for the reverse.
</p>




<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescCreate">CFAUOtherPluginDescCreate</h2>

<p><code>
CFAUOtherPluginDescRef CFAUOtherPluginDescCreate(CFAllocatorRef inAllocator, UInt32 inFormat, OSType inTypeID, OSType inSubTypeID, OSType inManufacturerID)
</code></p>

<p>
<var>inAllocator</var><br />
The allocator to use to allocate the memory via CFAllocatorAllocate.
</p>

<p>
<var>inFormat</var><br />
The value that you want set as the format value in the AudioUnitOtherPluginDesc.
</p>

<p>
<var>inTypeID</var><br />
The value that you want set as the mType value in the AudioUnitOtherPluginDesc.
</p>

<p>
<var>inSubTypeID</var><br />
The value that you want set as the mSubType value in the AudioUnitOtherPluginDesc.
</p>

<p>
<var>inManufacturerID</var><br />
The value that you want set as the mManufacturer value in the AudioUnitOtherPluginDesc.
</p>

<p>
<i><b>result</b></i><br />
A reference to a newly allocated CFAUOtherPluginDesc object containing an AudioUnitOtherPluginDesc with its fields set to the values as passed into this function.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function will allocate an instance of a CFAUOtherPluginDesc object and initialize the value fields of its contained AudioUnitOtherPluginDesc structure according to the corresponding arguments of the function.
</p>
<p>
The caller owns a reference to the returned CFAUOtherPluginDescRef and is responsible for releasing it when done.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</a> for a closely related example.
</p>




<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</h2>

<p><code>
CFAUOtherPluginDescRef CFAUOtherPluginDescCreateVST(CFAllocatorRef inAllocator, OSType inUniqueID)
</code></p>

<p>
<var>inAllocator</var><br />
The allocator to use to allocate the memory via CFAllocatorAllocate.
</p>

<p>
<var>inUniqueID</var><br />
The compatible VST plugin's &quot;unique ID&quot; value.
</p>

<p>
<i><b>result</b></i><br />
A reference to a newly allocated CFAUOtherPluginDesc object containing an AudioUnitOtherPluginDesc with its fields set correctly for specifying a VST plugin with the identifying value as passed into this function.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function will allocate an instance of a CFAUOtherPluginDesc object and initialize the value fields of its contained AudioUnitOtherPluginDesc structure according to specifying a VST plugin the corresponding argument of the function.
</p>
<p>
The caller owns a reference to the returned CFAUOtherPluginDescRef and is responsible for releasing it when done.
</p>
<p>
This function is a convenience wrapper for <a href="#CFAUOtherPluginDescCreate">CFAUOtherPluginDescCreate</a>.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example implementation the GetProperty method, specifically overridden for the kAudioUnitMigrateProperty_FromPlugin property, for an AUEffectBase-derived AU that has VST and MAS counterpart versions with importable settings:
</p>

<pre class="codesnippet">
OSStatus MegaEffect::GetProperty(AudioUnitPropertyID inPropertyID, 
					AudioUnitScope inScope, AudioUnitElement inElement, 
					void* outData)
{
	if (inPropertyID == kAudioUnitMigrateProperty_FromPlugin)
	{
		CFMutableArrayRef const descsArray = CFArrayCreateMutable(kCFAllocatorDefault, 2, &amp;kCFAUOtherPluginDescArrayCallBacks);
		if (!descsArray)
		{
			return coreFoundationUnknownErr;
		}

		if (CFAUOtherPluginDescRef const otherPluginMigrateDesc = CFAUOtherPluginDescCreateVST(kCFAllocatorDefault, 'Plug'))
		{
			CFArrayAppendValue(descsArray, otherPluginMigrateDesc);
			CFAUOtherPluginDescRelease(otherPluginMigrateDesc);
		}

		if (CFAUOtherPluginDescRef const otherPluginMigrateDesc = CFAUOtherPluginDescCreateMAS(kCFAllocatorDefault, 'Plug', 3, 'Acme'))
		{
			CFArrayAppendValue(descsArray, otherPluginMigrateDesc);
			CFAUOtherPluginDescRelease(otherPluginMigrateDesc);
		}

		std::memcpy(outData, &amp;descsArray, sizeof(descsArray));
		return noErr;
	}

	return AUEffectBase::GetProperty(inPropertyID, inScope, inElement, outData);
}
</pre>




<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescCreateMAS">CFAUOtherPluginDescCreateMAS</h2>

<p><code>
CFAUOtherPluginDescRef CFAUOtherPluginDescCreateMAS(CFAllocatorRef inAllocator, OSType inEffectID, OSType inVariantID, OSType inManufacturerID)
</code></p>

<p>
<var>inAllocator</var><br />
The allocator to use to allocate the memory via CFAllocatorAllocate.
</p>

<p>
<var>inEffectID</var><br />
The compatible MAS plugin's masEffectID value.
</p>

<p>
<var>inVariantID</var><br />
The compatible MAS plugin's masVariantID value.
</p>

<p>
<var>inManufacturerID</var><br />
The compatible MAS plugin's masManufacturer value.
</p>

<p>
<i><b>result</b></i><br />
A reference to a newly allocated CFAUOtherPluginDesc object containing an AudioUnitOtherPluginDesc with its fields set correctly for specifying a MAS plugin with the identifying values as passed into this function.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function will allocate an instance of a CFAUOtherPluginDesc object and initialize the value fields of its contained AudioUnitOtherPluginDesc structure according to specifying a MAS plugin the corresponding arguments of the function.
</p>
<p>
The caller owns a reference to the returned CFAUOtherPluginDescRef and is responsible for releasing it when done.
</p>
<p>
This function is a convenience wrapper for <a href="#CFAUOtherPluginDescCreate">CFAUOtherPluginDescCreate</a>.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</a> for a relevant example.
</p>




<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescRetain">CFAUOtherPluginDescRetain</h2>

<p><code>
CFAUOtherPluginDescRef CFAUOtherPluginDescRetain(CFAUOtherPluginDescRef inDesc)
</code></p>

<p>
<var>inPreset</var><br />
A reference to a CFAUOtherPluginDesc object to be retained.
</p>

<p>
<i><b>result</b></i><br />
A reference to the CFAUOtherPluginDesc object that was retained.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function mimics the behavior of CFRetain, but specifically for the CFAUOtherPluginDescRef type and not any CFTypeRef.
</p>



<p><br /></p>
<hr />

<h2 id="CFAUOtherPluginDescRelease">CFAUOtherPluginDescRelease</h2>

<p><code>
void CFAUOtherPluginDescRelease(CFAUOtherPluginDescRef inDesc)
</code></p>

<p>
<var>inPreset</var><br />
A reference to a CFAUOtherPluginDesc object to be released.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function mimics the behavior of CFRelease, but specifically for the CFAUOtherPluginDescRef type and not any CFTypeRef.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</a> for a relevant example.
</p>



<p><br /></p>
<hr />

<h2 id="kCFAUOtherPluginDescArrayCallBacks">kCFAUOtherPluginDescArrayCallBacks</h2>

<p><code>
CFArrayCallBacks const kCFAUOtherPluginDescArrayCallBacks
</code></p>


<p><br /></p>
<h3>explanation</h3>

<p>
This CFArrayCallbacks structure is initialized (when your code is loaded) to contain pointers to callbacks that will correctly handle retaining, releasing, comparing, and describing CFArrays that contain <a href="#CFAUOtherPluginDescRef">CFAUOtherPluginDescRef</a> instances as their data items.  You can pass this for the CFArrayCallbacks* argument when creating arrays with CFArrayCreate or CFArrayCreateMutable.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#CFAUOtherPluginDescCreateVST">CFAUOtherPluginDescCreateVST</a> for a relevant example.
</p>






<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="plugin_name_and_manufacturer_name">Getting an AU's plugin name and manufacturer name</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
Audio Unit Component names are formatted in this certain way:  "Manufacturer Name: Plugin Name".  Very often, AU hosts want to parse out just the plugin name or just the manufacturer name to display to the user.  So that is what these functions do.  It's a common thing to need to do, and a pretty simple thing, but still I see no reason why every host author should need to write their own parsing code redundantly, so I'm sharing mine.  Plus I needed to write this code for the <a href="#preset_files">AU preset file handling stuff</a> anyway.
</p>

<p>
Please note that the "manufacturer: plugin" name format is only an Audio Unit thing, so these functions are not useful for other types of Components.
</p>


<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#CopyAUNameAndManufacturerStrings">CopyAUNameAndManufacturerStrings</a>
</p>



<p><br /></p>
<hr />

<h2 id="CopyAUNameAndManufacturerStrings">CopyAUNameAndManufacturerStrings</h2>

<p><code>
OSStatus CopyAUNameAndManufacturerStrings(AudioComponent inAUComponent, CFStringRef* outNameString, CFStringRef* outManufacturerString)
</code></p>

<p>
<var>inAUComponent</var><br />
The AU Component whose plugin name and/or manufacturer name you want.
</p>

<p>
<var>outNameString</var><br />
Upon successful return, the CFStringRef will reference a CFString representation of the Audio Unit's specific plugin name.  Can be NULL.
</p>

<p>
<var>outManufacturerString</var><br />
Upon successful return, the CFStringRef will reference a CFString representation of the Audio Unit's manufacturer name.  Can be NULL.
</p>

<p>
<i><b>result</b></i><br />
A status code:  noErr if the operation was successful, otherwise some appropriate error code.  If there was any problem creating the CFStrings, coreFoundationUnknownErr is returned.  If getting the AudioComponent name info fails, the error code is the one returned by AudioComponentCopyName.  If the AudioComponent name string is not in the proper AU colon-delimited format, internalComponentErr is returned.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
If you only want the plugin name or only want the manufacturer name, you can send a valid pointer to a CFStringRef for the one that you want and NULL for the other one.  You cannot, however, send NULL for both.  Doing that will result in a paramErr return value.
</p>

<p>
The caller owns a reference to each output CFString and is responsible for releasing them when done.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example of getting the name strings for an AU and outputting them to stderr:
</p>

<pre class="codesnippet">
CFStringRef nameString = NULL, manufacturerString = NULL;
OSStatus const error = CopyAUNameAndManufacturerStrings(someAUComponent, &amp;nameString, &amp;manufacturerString);
if (error == noErr)
{
	fprintf(stderr, "the name of this plugin is:  ");
	CFShow(nameString);

	fprintf(stderr, "the name of this plugin's manufacturer is:  ");
	CFShow(manufacturerString);

	CFRelease(nameString);
	CFRelease(manufacturerString);
}
</pre>









<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="comparing_component_descriptions">Comparing ComponentDescriptions</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
An AudioComponentDescription is a struct that contains values that together uniquely identify an AudioComponent (an Audio Unit is a type of AudioComponent).  It is what you use to programatically describe a specific AudioComponent.  The struct contains five values, but only three of them are actually used for the purposes of uniquely identifying the AU.  Occasionally it is useful to compare ComponentDescriptions to see if they match, so these are just some convenience functions that make that simple, comparing on the basis of the three identifying values:  the type, sub-type, and manufacturer IDs.  For example, <a href="#CFTreeCreateFromAUPresetFilesInDomain">CFTreeCreateFromAUPresetFilesInDomain</a> uses these functions to compare the AudioComponentDescription that <a href="#GetAUComponentDescriptionFromPresetFile">GetAUComponentDescriptionFromPresetFile</a> supplies to that of a particular AudioComponent.
</p>

<p>
These functions also come in &quot;loosely&quot; varieties which match only the sub-type and manufacturer codes (ignoring the type code).  The reason for this is that Apple changed the expectations of settings data compatibility in August 2005 (with the release of the CoreAudio SDK version 1.4.2) to allow for compatibility between settings that don't match the type code of a given AU.  This allows for you to make different varieties of AUs that are essentially the same plugin in most senses, but different in their type categories (e.g. you may have an offline version and a realtime effect version of some effect).  These would share the same sub-type and manufacturer codes and would be expected to be able to read each other's settings data interchangeably.
</p>


<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#ComponentDescriptionsMatch">ComponentDescriptionsMatch</a>
<br />
<a href="#ComponentDescriptionsMatch_Loosely">ComponentDescriptionsMatch_Loosely</a>
<br />
<a href="#ComponentAndDescriptionMatch">ComponentAndDescriptionMatch</a>
<br />
<a href="#ComponentAndDescriptionMatch_Loosely">ComponentAndDescriptionMatch_Loosely</a>
</p>



<p><br /></p>
<hr />

<h2 id="ComponentDescriptionsMatch">ComponentDescriptionsMatch</h2>

<p><code>
Boolean ComponentDescriptionsMatch(AudioComponentDescription const* inComponentDescription1, AudioComponentDescription const* inComponentDescription2)
</code></p>

<p>
<var>inComponentDescription1</var><br />
A pointer to one of the ComponentDescriptions that you want to compare.
</p>

<p>
<var>inComponentDescription2</var><br />
A pointer to the AudioComponentDescription that you want to compare to inComponentDescription1.
</p>

<p>
<i><b>result</b></i><br />
The result is TRUE if both ComponentDescriptions match, and FALSE otherwise.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function compares two ComponentDescriptions to see if they match based on their identifying values.
</p>



<p><br /></p>
<hr />

<h2 id="ComponentDescriptionsMatch_Loosely">ComponentDescriptionsMatch_Loosely</h2>

<p><code>
Boolean ComponentDescriptionsMatch_Loosely(AudioComponentDescription const* inComponentDescription1, AudioComponentDescription const* inComponentDescription2)
</code></p>

<p>
<var>inComponentDescription1</var><br />
A pointer to one of the ComponentDescriptions that you want to compare.
</p>

<p>
<var>inComponentDescription2</var><br />
A pointer to the AudioComponentDescription that you want to compare to inComponentDescription1.
</p>

<p>
<i><b>result</b></i><br />
The result is TRUE if the sub-type and manufacturer codes of both ComponentDescriptions match, and FALSE otherwise.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function is the same as <a href="#ComponentDescriptionsMatch">ComponentDescriptionsMatch</a> except that it ignores the type codes when comparing.
</p>






<p><br /></p>
<hr />

<h2 id="ComponentAndDescriptionMatch">ComponentAndDescriptionMatch</h2>

<p><code>
Boolean ComponentAndDescriptionMatch(AudioComponent inComponent, AudioComponentDescription const* inComponentDescription))
</code></p>

<p>
<var>inComponent</var><br />
An AudioComponent whose AudioComponentDescription you want to compare to another AudioComponentDescription.
</p>

<p>
<var>inComponentDescription</var><br />
The AudioComponentDescription that you want to compare to inComponent's AudioComponentDescription.
</p>

<p>
<i><b>result</b></i><br />
The result is TRUE if inComponent's AudioComponentDescription matches inComponentDescription, and FALSE otherwise.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
If you are starting with an AudioComponent that you want to compare to some AudioComponentDescription, then this function will do the work of querying the AudioComponent's AudioComponentDescription and then comparing those two ComponentDescriptions to see if they match.  If querying the AudioComponentDescription of inComponent's fails, then the function will return FALSE.
</p>

<p>
This function is a convenience wrapper for <a href="#ComponentDescriptionsMatch">ComponentDescriptionsMatch</a>.
</p>






<p><br /></p>
<hr />

<h2 id="ComponentAndDescriptionMatch_Loosely">ComponentAndDescriptionMatch_Loosely</h2>

<p><code>
Boolean ComponentAndDescriptionMatch_Loosely(AudioComponent inComponent, AudioComponentDescription const* inComponentDescription)
</code></p>

<p>
<var>inComponent</var><br />
An AudioComponent whose AudioComponentDescription you want to compare to another AudioComponentDescription.
</p>

<p>
<var>inComponentDescription</var><br />
The AudioComponentDescription that you want to compare to inComponent's AudioComponentDescription.
</p>

<p>
<i><b>result</b></i><br />
The result is TRUE if inComponent's sub-type and manufacturer codes match inComponentDescription's, and FALSE otherwise.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function is the same as <a href="#ComponentAndDescriptionMatch">ComponentAndDescriptionMatch</a> except that it ignores the type codes when comparing.
</p>









<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h1 class="bigsection" id="parameter_change_notification">Posting parameter change notifications</h1>


<p><br /></p>
<h3>Why this matters</h3>

<p>
Sometimes a change occurs to an Audio Unit's parameter of which other interested parties might not be aware.  For example, an AU might do something in a certain context that changes a parameter value internally (like mapping a MIDI CC event to a parameter change), and maybe the GUI or some other user interface might want to be notified so that it can update itself to reflect that change.  These functions provide easy ways to do that.  AU has a nice system for sending parameter change notifications to any arbitrary number of parameter listeners, and these functions are just a wrappers for that part of the AU API.  I found myself writing the same little six line function over and over again in every AU that I developed, so I figured I would just make one reusable function for them all.  So these functions are just for convenience, they don't provide any extra functionality.
</p>


<p><br /></p>
<h3>Functions</h3>

<p>
<a href="#AUParameterChange_TellListeners_ScopeElement">AUParameterChange_TellListeners_ScopeElement</a>
<br />
<a href="#AUParameterChange_TellListeners">AUParameterChange_TellListeners</a>
</p>



<p><br /></p>
<hr />

<h2 id="AUParameterChange_TellListeners_ScopeElement">AUParameterChange_TellListeners_ScopeElement</h2>

<p><code>
void AUParameterChange_TellListeners_ScopeElement(AudioComponentInstance inAUComponentInstance, AudioUnitParameterID inParameterID, AudioUnitScope inScope, AudioUnitElement inElement)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose parameter value has changed.
</p>

<p>
<var>inParameterID</var><br />
The ID of the changed parameter.
</p>

<p>
<var>inScope</var><br />
The scope of the changed parameter.
</p>

<p>
<var>inElement</var><br />
The element of the changed parameter.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function is a convenience wrapper of AUParameterListenerNotify, which is part of the regular Audio Unit API.  When you use AUParameterListenerNotify, you need to have an AudioUnitParameter structure, initialize all of its values, and then call AUParameterListenerNotify.  This function just lets you do that in one line rather than six.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
See <a href="#AUParameterChange_TellListeners">AUParameterChange_TellListeners</a> for a relevant example.
</p>







<p><br /></p>
<hr />

<h2 id="AUParameterChange_TellListeners">AUParameterChange_TellListeners</h2>

<p><code>
void AUParameterChange_TellListeners(AudioComponentInstance inAUComponentInstance, AudioUnitParameterID inParameterID)
</code></p>

<p>
<var>inAUComponentInstance</var><br />
The Audio Unit instance whose parameter value has changed.
</p>

<p>
<var>inParameterID</var><br />
The ID of the changed parameter.
</p>


<p><br /></p>
<h3>explanation</h3>

<p>
This function is a convenience wrapper of a convenience wrapper.  It simply calls <a href="#AUParameterChange_TellListeners_ScopeElement">AUParameterChange_TellListeners_ScopeElement</a> passing kAudioUnitScope_Global for the scope value and 0 for the element value.  Since I find that, most of the time, my AUs' parameters are in the global scope and element 0, I rarely ever need specify other scopes or elements, so I made this simplified function.
</p>


<p><br /></p>
<h3>programming example</h3>

<p>
Here's an example of sending change notifications for every parameter right after a factory preset has been loaded:
</p>

<pre class="codesnippet">
OSStatus MegaEffect::NewFactoryPresetSet(AUPreset const&amp; inNewFactoryPreset)
{
	// ...do something to load the factory preset settings...

	for (UInt32 i = 0; i &lt; yourNumParameters; i++)
	{
		AUParameterChange_TellListeners(GetComponentInstance(), yourParameterList[i]);
	}

	return noErr;
}
</pre>






<p>
<br />
<br />
<br />
</p>
<hr class="bigsection" />
<hr class="bigsection" />
<h2 id="history">Change log</h2>

<p>
November 29th 2020:
</p>
<ul>
	<li>removed the function CustomRestoreAUPresetFile as part of generally removing all functionality that required custom dialog UI code (since those system APIs have become asynchronous and therefore more complicated to provide via library)</li>
	<li>SaveAUStateToPresetFile and SaveAUStateToPresetFile_Bundle no longer present a file save user dialog but instead save only to the default user domain location, and potentially present an alert dialog if a file already exists at that path (dependent upon the value of the new inPromptToReplaceFile parameter)</li>
	<li>added CustomSaveAUPresetFile and CustomSaveAUPresetFile_Bundle functions to allow saving AU preset files to the non-default location</li>
	<li>removed the function GetComponentVersionFromResource since the Carbon Component Manager API is long-deprecated (and eliminated for Apple Silicon Macs)</li>
	<li>updated many functions to take Audio Component API types rather than deprecated Component Manager types</li>
	<li>removed the fuction GetAUNameAndManufacturerCStrings because it was redundant and lacked clear memory ownership semantics</li>
	<li>removed the function FSRefIsAUPreset because it was redundant and FSRef is deprecated</li>
	<li>added DFXFileSystemDomain enum rather than relying upon the deprecated Find Folder system API constants</li>
	<li>removed all of the system version checking / availability functions GetMacOSVersion, GetQuickTimeVersion, GetAudioToolboxFrameworkVersion, IsAvailable_AU2rev1, and IsTransportStateProcSafe since the old problematic versions of things for which these existed to identify are all ancient and long-unsupported</li>
</ul>

<p>
May 8th 2008:
</p>
<ul>
	<li>added the function GetAUComponentDescriptionFromStateData()</li>
	<li>removed the domain choice radio control from the dialog presented in SaveAUStateToPresetFile() and SaveAUStateToPresetFile_Bundle(), since really user preset files should just go in the user domain, the user may not even have write access for other domains, etc., and therefore I decided that other save-to domains should not be presented as options</li>
	<li>fixed a possible small memory leak in CreateSavePresetDialog()</li>
	<li>removed several unnecessary const qualifiers from function arguments that were already const CFTypes</li>
	<li>now correctly using a unique creator code for the ControlID signature value of the controls in the dialog windows</li>
</ul>

<p>
August 18th 2006:
</p>
<ul>
	<li><strong style="text-decoration: underline blink">IMPORTANT:</strong>  The behavior of the CFArray callbacks for Factory Presets has changed.  Your code must be updated in order to use the current implementation.  I broke backwards compatibility because the previous implementation was critically flawed and needed to be completely redone and should have never been released as it was.  It potentially could cause crashing or other undesirable misbehavior.  I apologize for the mistake.  You must use the new type CFAUPresetRef and related functions CFAUPresetCreate(), CFAUPresetRetain(), and CFAUPresetRelease() that have been added in this release of this library.  In order to hopefully make it harder for developers to miss this change, I changed the name of the kAUPresetCFArrayCallbacks constant to kCFAUPresetArrayCallBacks, therefore breaking backwards compatibility at compile time as well.</li>
	<li>removed the function AUPresetCFArrayCallbacks_Init() from the public interface since the type that it handles is now private</li>
	<li>added the type CFAUOtherPluginDescRef; the functions CFAUOtherPluginDescCreate(), CFAUOtherPluginDescCreateVST(), CFAUOtherPluginDescCreateMAS(), CFAUOtherPluginDescRetain(), and CFAUOtherPluginDescRelease(); and the constant kCFAUOtherPluginDescArrayCallBacks</li>
</ul>

<p>
September 9th 2005:
</p>
<ul>
	<li>in CopyAUNameAndManufacturerStrings(), changed all calls to CFStringCreateWithCString() to use kCFStringEncodingMacRoman for the string encoding parameter, since that is the only encoding that is allowed in the old-style Pascal string <code>'STR '</code> resources</li>
</ul>

<p>
August 12th 2005:
</p>
<ul>
	<li>added the functions ComponentDescriptionsMatch_Loosely() and ComponentAndDescriptionMatch_Loosely()</li>
	<li>CustomRestoreAUPresetFile() and CFTreeCreateFromAUPresetFilesInDomain() now use ComponentAndDescriptionMatch_Loosely() rather than ComponentAndDescriptionMatch() to determine which preset files can be used for a given AU, as per the recent recommendations given by Apple and implemented in AUBase::RestoreState() in the 1.4.2 update of the CoreAudio SDK</li>
</ul>

<p>
March 6th 2005:
</p>
<ul>
	<li>added the AudioComponentDescription comparator functions ComponentDescriptionsMatch() and ComponentAndDescriptionMatch()</li>
	<li>added the function GetAUComponentDescriptionFromPresetFile()</li>
	<li>modified the behavior of CFTreeCreateFromAUPresetFilesInDomain() and CustomRestoreAUPresetFile() so that they now open and examine the AU preset files that they encounter and evaluate whether their data is for the specified AU</li>
	<li>added the function IsTransportStateProcSafe()</li>
	<li>RestoreAUStateFromPresetFile() now sends parameter change notifications to the Input and Output, not only the Global scope (for any AUs that might have public parameters on those scopes as well)</li>
	<li>TranslateCFStringToUnicodeString() now does proper character-aware truncation of Unicode strings that are longer than the maximum HFS file name length</li>
</ul>

<p>
June 14th 2004:
</p>
<ul>
	<li>changed the source code and binary code's license from the GNU Lesser General Public License to a modified BSD License so that it is easier for others to incorporate this library into a closed-source software project</li>
	<li>added four new system availability convenience functions:  GetMacOSVersion(), GetQuickTimeVersion(), GetAudioToolboxFrameworkVersion(), and IsAvailable_AU2rev1()</li>
	<li>RestoreAUStateFromPresetFile() now will, upon success, post notification of changed parameter values to any AU parameter listeners</li>
	<li>ShouldReplaceExistingAUPresetFile() now creates a StandardAlert dialog of type kAlertNoteAlert rather than kAlertCautionAlert (as per the specifications in the Apple Human Interface Guidelines for Mac OS X) when the user is to be asked whether to replace an existing file</li>
	<li>CustomSaveAUPresetNavEventHandler() is a little safer now (checks to see whether the file name CFString is null)</li>
</ul>

<p>
September 23rd 2003:
</p>
<ul>
	<li>added French localizations by <a href="http://airy.andre.online.fr/">Airy Andr&eacute;</a></li>
	<li>shortened the file names of the localizable.strings files so that they will survive Mac OS 9 network file sharing transfers</li>
	<li><a href="http://koen.smartelectronix.com/">Koen Tanghe</a> finished the Dutch localization (the control help tags in the nib were accidentally left in English in the first release)</li>
</ul>

<p>
September 18th 2003:
</p>
<ul>
	<li>first release</li>
</ul>






<p><br /></p>
<hr />

<p class="footer">
Copyright &copy; 2003-2023 Sophia Poirier
</p>
<p class="footer">
Permission is granted to copy, distribute and/or modify this document under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation License</a>, Version 1.2 or any later version published by the <a href="http://www.fsf.org/">Free Software Foundation</a>.  A copy of the license is included in the file &quot;fdl.txt&quot;.
</p>
<p class="footer">
The latest version of this document can be found <a href="http://destroyfx.org/dfx-au-utilities.html">here</a>.
</p>






</body>
</html>
